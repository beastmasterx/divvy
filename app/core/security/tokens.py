"""
General authentication token utilities.

Includes access tokens (JWT) and refresh tokens (random tokens) used for
general authentication, not OAuth-specific flows.
"""

import hashlib
import secrets
from datetime import UTC, datetime, timedelta
from typing import Any

from jose import jwt

from ..config import JWT_ALGORITHM, get_jwt_access_token_expire_seconds, get_jwt_secret_key


def generate_refresh_token() -> tuple[str, str]:
    """
    Generate a cryptographically secure refresh token and its hash.

    Generates a URL-safe random token suitable for use as a refresh token.
    Returns both the plain token (to be sent to the client) and its hash
    (to be stored in the database). The plain token should only be returned
    once immediately after generation.

    Returns:
        Tuple containing:
        - Plain text refresh token (str): To be sent to the client
        - Hashed token (str): To be stored in the database for verification

    Note:
        The plain token should be returned to the client only once.
        Only the hash should be stored in the database for security.

    Example:
        >>> token, token_hash = generate_refresh_token()
        >>> check_refresh_token(token, token_hash)
        True
    """
    token = secrets.token_urlsafe(32)
    hash = hash_refresh_token(token)
    return token, hash


def hash_refresh_token(value: str) -> str:
    """
    Hash a refresh token using SHA-256.

    Creates a one-way hash of a refresh token for secure storage.
    The hash cannot be reversed to obtain the original token.

    Args:
        value: Plain text refresh token to hash

    Returns:
        SHA-256 hexadecimal hash of the token (64 characters)

    Note:
        This is a one-way hash function. Use check_refresh_token()
        to verify if a token matches a stored hash.
    """
    return hashlib.sha256(value.encode("utf-8")).hexdigest()


def check_refresh_token(token: str, hash: str) -> bool:
    """
    Verify if a refresh token matches its stored hash.

    Compares a plain text refresh token against a previously hashed token
    to determine if they match. Used to verify refresh tokens during
    token refresh operations.

    Args:
        token: Plain text refresh token to verify
        hash: SHA-256 hash string (previously generated by hash_refresh_token)

    Returns:
        True if the token matches the hash, False otherwise

    Example:
        >>> token, token_hash = generate_refresh_token()
        >>> check_refresh_token(token, token_hash)
        True
        >>> check_refresh_token("wrong_token", token_hash)
        False
    """
    return hash_refresh_token(token) == hash


def generate_access_token(data: dict[str, Any], expires_delta: timedelta | None = None) -> str:
    """
    Generate a JWT access token.

    Args:
        data: Dictionary containing token payload (typically user_id and email)
        expires_delta: expiration time delta (e.g. timedelta(minutes=30)).

    Returns:
        Encoded JWT token string
    """
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(UTC) + expires_delta
    else:
        expire = datetime.now(UTC) + timedelta(seconds=get_jwt_access_token_expire_seconds())

    to_encode.update({"exp": expire, "iat": datetime.now(UTC)})
    encoded_jwt = jwt.encode(to_encode, get_jwt_secret_key(), algorithm=JWT_ALGORITHM)
    return encoded_jwt


def verify_access_token(token: str, options: dict[str, Any] | None = None) -> dict[str, Any]:
    """
    Verify and decode a JWT access token.

    Verifies the token's signature using the configured secret key and algorithm,
    and by default also validates the expiration time (unless disabled via options).
    Returns the decoded payload containing all claims (e.g., 'sub', 'email', 'exp', 'iat').

    Args:
        token: JWT token string to verify and decode
        options: Optional dictionary of verification options to pass to the JWT decoder.
            Common options:
            - {"verify_exp": False} - Skip expiration validation
            - {"verify_signature": False} - Skip signature verification (not recommended)
            If None, uses default verification settings (expiration is verified).

    Returns:
        Decoded token payload as a dictionary containing all JWT claims.
        Typically includes 'sub' (subject/user_id), 'email', 'exp' (expiration),
        and 'iat' (issued at) claims.

    Raises:
        JWTError: If token is invalid, expired (when verify_exp is True),
            has an invalid signature, uses an unsupported algorithm, or is malformed.
        ValueError: If the token cannot be decoded or parsed.
    """
    return jwt.decode(token, get_jwt_secret_key(), algorithms=[JWT_ALGORITHM], options=options)


def get_access_token_expires_in(token: str) -> int:
    """
    Extract expiration time in seconds from a JWT token.

    Decodes the token without verifying expiration to extract the 'exp' claim,
    then calculates the remaining seconds until expiration.

    Args:
        token: JWT token string to extract expiration from

    Returns:
        Number of seconds until token expiration, or the default expiration time if the token
        doesn't contain an 'exp' claim. Returns 0 if the token has already expired.

    Raises:
        JWTError: If token is invalid, malformed.
        ValueError: If the token cannot be decoded or parsed
    """
    payload: dict[str, Any] = verify_access_token(token, {"verify_exp": False})
    exp: float | int | None = payload.get("exp")

    if exp is not None:
        now: float = datetime.now(UTC).timestamp()
        expires_in = int(exp - now)
        return max(0, expires_in)

    return get_jwt_access_token_expire_seconds()
